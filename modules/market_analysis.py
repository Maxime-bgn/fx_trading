"""
Module 2 ‚Äî Market Analysis
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import glob
import os
from scipy.optimize import minimize

TRADING_DAYS = 252
MAX_WEIGHT = 0.20

@st.cache_data
def load_prices():
    prices = {}
    for file in glob.glob("*=X.csv"):
        pair = os.path.basename(file).replace("=X.csv", "")
        try:
            df = pd.read_csv(file, sep=";", decimal=",",
                             index_col=0, parse_dates=True)
            if "Close" not in df.columns:
                continue
            df["Close"] = pd.to_numeric(df["Close"], errors="coerce")
            prices[pair] = df["Close"]
        except Exception:
            continue
    prices_df = pd.DataFrame(prices).dropna()
    return prices_df


@st.cache_data
def load_returns():
    """Load fx_returns.csv ‚Äî generated by returns.py."""
    try:
        return pd.read_csv("fx_returns.csv", sep=";", decimal=",",
                           index_col=0, parse_dates=True)
    except Exception:
        return None


def port_return(w, mu):
    return np.dot(w, mu)

def port_vol(w, Sigma):
    return np.sqrt(w.T @ Sigma @ w)

def neg_sharpe(w, mu, Sigma):
    return -port_return(w, mu) / port_vol(w, Sigma)


@st.cache_data
def run_markowitz(returns_df):
    returns_df = returns_df.dropna(axis=1, thresh=200).dropna()
    mu    = returns_df.mean() * TRADING_DAYS
    Sigma = returns_df.cov()  * TRADING_DAYS
    n     = len(mu)
    w0    = np.ones(n) / n
    bounds      = [(0, MAX_WEIGHT)] * n
    constraints = {"type": "eq", "fun": lambda w: np.sum(w) - 1}

    res_minvar = minimize(
        lambda w: port_vol(w, Sigma), w0,
        method="SLSQP", bounds=bounds, constraints=constraints
    )
    res_maxsh = minimize(
        lambda w: neg_sharpe(w, mu, Sigma), w0,
        method="SLSQP", bounds=bounds, constraints=constraints
    )

    w_minvar    = res_minvar.x
    w_maxsharpe = res_maxsh.x

    target_returns = np.linspace(
        port_return(w_minvar, mu),
        port_return(w_maxsharpe, mu), 15
    )

    frontier_vol_list, frontier_ret_list = [], []
    for R in target_returns:
        cons = (
            constraints,
            {"type": "eq", "fun": lambda w, R=R: port_return(w, mu) - R}
        )
        res = minimize(
            lambda w: port_vol(w, Sigma), w0,
            method="SLSQP", bounds=bounds, constraints=cons
        )
        if res.success:
            frontier_vol_list.append(port_vol(res.x, Sigma))
            frontier_ret_list.append(port_return(res.x, mu))

    return (mu, Sigma, w_minvar, w_maxsharpe,
            frontier_vol_list, frontier_ret_list,
            returns_df.columns)


PAIRS_RAPPORT = ["EUR/USD","GBP/USD","USD/JPY","USD/CHF",
                 "AUD/USD","AUD/CAD","AUD/JPY","NZD/JPY",
                 "EUR/NOK","USD/INR","USD/CNH"]

SCORES_DATA = {
    "Pair":        PAIRS_RAPPORT,
    "Total Score": [0.92,0.87,0.90,0.85,0.83,0.76,0.79,0.73,0.62,0.71,0.78],
    "Liquidity":   [0.98,0.92,0.97,0.85,0.82,0.65,0.72,0.60,0.42,0.55,0.72],
    "Volatility":  [0.88,0.82,0.85,0.90,0.80,0.78,0.75,0.70,0.72,0.78,0.82],
    "Correlation": [0.90,0.85,0.88,0.82,0.85,0.92,0.88,0.85,0.95,0.97,0.88],
    "Spread":      [0.95,0.88,0.95,0.82,0.80,0.68,0.72,0.55,0.38,0.45,0.72],
    "Hurst (H)":   [0.52,0.56,0.48,0.43,0.54,0.49,0.51,0.51,0.47,0.52,0.48],
    "Allocation":  ["20%","15%","15%","10%","10%","5%","8%","5%","4%","5%","3%"],
    "Strategy":    ["All","Momentum","Mean-Rev","Mean-Rev","Momentum",
                    "Mean-Rev","Carry","Carry","Mean-Rev Swing","Carry","Carry"],
}


def show():
    st.title("Market Analysis")
    st.markdown("---")

    prices_df  = load_prices()
    returns_df = load_returns()

    st.subheader("Portfolio Correlation Matrix")

    if prices_df is not None and prices_df.shape[1] >= 2:
        corr = prices_df.corr()
        pairs_labels = list(corr.columns)
        corr_matrix  = corr.values
    else:
        st.warning("CSV files not found ‚Äî displaying report data")
        pairs_labels = PAIRS_RAPPORT
        corr_matrix  = np.eye(len(PAIRS_RAPPORT))

    fig_heat = go.Figure(go.Heatmap(
        z=corr_matrix,
        x=pairs_labels, y=pairs_labels,
        colorscale=[
            [0.00, "#1a5276"],
            [0.35, "#2980b9"],
            [0.50, "#f5f5f5"],
            [0.65, "#e74c3c"],
            [1.00, "#922b21"],
        ],
        zmid=0, zmin=-1, zmax=1,
        text=np.round(corr_matrix, 2),
        texttemplate="%{text}",
        textfont=dict(size=8),
        hovertemplate="%{y} / %{x}<br>œÅ = %{z:.2f}<extra></extra>",
        colorbar=dict(title="œÅ", thickness=15)
    ))
    fig_heat.update_layout(
        template="plotly_dark", paper_bgcolor="#161b22",
        height=520, margin=dict(l=0, r=0, t=20, b=0),
        xaxis=dict(tickangle=-45, tickfont=dict(size=9)),
        yaxis=dict(tickfont=dict(size=9)),
    )
    st.plotly_chart(fig_heat, use_container_width=True)

    if prices_df is not None:
        n = len(pairs_labels)
        mask = ~np.eye(n, dtype=bool)
        rho_mean = corr_matrix[mask].mean()
        c1, c2, c3 = st.columns(3)
        with c1:
            icon = "üü¢" if rho_mean < 0.30 else "üî¥"
            st.metric("Average Correlation", f"{rho_mean:.2f}",
                      f"{icon} {'Target reached' if rho_mean < 0.30 else 'Above 0.30'}")
        with c2:
            st.metric("Number of pairs", str(n))
        with c3:
            min_corr_pair = corr.abs().replace(1, np.nan).stack().idxmin()
            st.metric("Least correlated pair",
                      f"{min_corr_pair[0]} / {min_corr_pair[1]}")

    st.markdown("---")

    st.subheader("Composite Pair Scoring")

    df = pd.DataFrame(SCORES_DATA)
    st.dataframe(df, use_container_width=True, hide_index=True,
        column_config={
            "Total Score": st.column_config.ProgressColumn(
                "Total Score", min_value=0, max_value=1, format="%.2f"),
            "Liquidity":   st.column_config.ProgressColumn(
                "L", min_value=0, max_value=1, format="%.2f"),
            "Volatility":  st.column_config.ProgressColumn(
                "V", min_value=0, max_value=1, format="%.2f"),
            "Correlation": st.column_config.ProgressColumn(
                "C", min_value=0, max_value=1, format="%.2f"),
            "Spread":      st.column_config.ProgressColumn(
                "S", min_value=0, max_value=1, format="%.2f"),
        }
    )

    st.markdown("---")

    st.subheader("Hurst Ratio ‚Äî Market Regimes")

    hurst_vals = df["Hurst (H)"].values
    bar_colors = ["#3fb950" if h > 0.52 else
                  "#58a6ff" if h < 0.48 else "#d29922"
                  for h in hurst_vals]

    fig_hurst = go.Figure()
    fig_hurst.add_trace(go.Bar(
        x=PAIRS_RAPPORT, y=hurst_vals,
        marker_color=bar_colors,
        text=[f"{h:.2f}" for h in hurst_vals],
        textposition="outside",
    ))
    fig_hurst.add_hline(y=0.5, line_dash="dash", line_color="white",
                        annotation_text="H=0.5", annotation_position="right")
    fig_hurst.add_hrect(y0=0.5, y1=0.65,
                        fillcolor="rgba(63,185,80,0.07)", line_width=0)
    fig_hurst.add_hrect(y0=0.35, y1=0.5,
                        fillcolor="rgba(88,166,255,0.07)", line_width=0)
    fig_hurst.update_layout(
        template="plotly_dark", paper_bgcolor="#161b22",
        plot_bgcolor="#0d1117", height=360,
        xaxis=dict(tickangle=-30, gridcolor="#21262d"),
        yaxis=dict(title="Hurst (H)", gridcolor="#21262d", range=[0.30, 0.70]),
        margin=dict(l=0, r=60, t=20, b=0), showlegend=False,
    )
    st.plotly_chart(fig_hurst, use_container_width=True)

    st.markdown("---")

    st.subheader("Efficient Frontier ‚Äî Markowitz Optimization")

    if returns_df is not None:
        with st.spinner("Computing efficient frontier..."):
            try:
                (mu, Sigma, w_minvar, w_maxsharpe,
                frontier_vol, frontier_ret,
                col_names) = run_markowitz(returns_df)

                fig_mk = go.Figure()

                fig_mk.add_trace(go.Scatter(
                    x=frontier_vol, y=frontier_ret,
                    mode="lines", name="Efficient Frontier",
                    line=dict(color="#58a6ff", width=2.5)
                ))
                fig_mk.add_trace(go.Scatter(
                    x=[port_vol(w_minvar, Sigma)],
                    y=[port_return(w_minvar, mu)],
                    mode="markers", name="Minimum Variance",
                    marker=dict(color="#3fb950", size=14, symbol="star")
                ))
                fig_mk.add_trace(go.Scatter(
                    x=[port_vol(w_maxsharpe, Sigma)],
                    y=[port_return(w_maxsharpe, mu)],
                    mode="markers", name="Maximum Sharpe",
                    marker=dict(color="#f85149", size=14, symbol="star")
                ))

                fig_mk.update_layout(
                    template="plotly_dark", paper_bgcolor="#161b22",
                    plot_bgcolor="#0d1117", height=400,
                    xaxis=dict(title="Risk (Annualized Volatility)",
                            gridcolor="#21262d", tickformat=".1%"),
                    yaxis=dict(title="Annualized Return",
                            gridcolor="#21262d", tickformat=".1%"),
                    legend=dict(orientation="h", y=1.05),
                    margin=dict(l=0, r=0, t=30, b=0),
                )
                st.plotly_chart(fig_mk, use_container_width=True)

                st.subheader("Optimal Allocations per Pair")
                weights_df = pd.DataFrame({
                    "Pair":         list(col_names),
                    "Min Variance": [f"{w*100:.1f}%" for w in w_minvar],
                    "Max Sharpe":   [f"{w*100:.1f}%" for w in w_maxsharpe],
                })
                weights_df = weights_df[weights_df["Max Sharpe"] != "0.0%"]
                st.dataframe(weights_df, use_container_width=True,
                            hide_index=True)

            except Exception as e:
                st.error(f"Markowitz computation error: {e}")
    else:
        st.warning("fx_returns.csv not found ‚Äî run returns.py first")