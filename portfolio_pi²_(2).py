# -*- coding: utf-8 -*-
"""Portfolio_PI² (2).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_sXKhbiTuDAdxK8g0b07FVIVD3iof4Az
"""

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import cvxpy as cp
from IPython.display import display

returns_df = pd.read_csv(
    "fx_returns.csv",
    sep=";",
    decimal=",",
    index_col=0,
    parse_dates=True
)

returns_df = returns_df.sort_index()
returns_df = returns_df.dropna(how="any")

print(returns_df.head())
print("Shape:", returns_df.shape)

print(returns_df.describe())

# corrélations des paires

# Matrice de corrélation
corr = returns_df.corr()

plt.figure(figsize=(12, 10))

sns.heatmap(
    corr,
    cmap="RdBu_r",      # rouge = corr positive, bleu = négative
    center=0,           # centre la couleur sur 0
    vmin=-1, vmax=1,
    square=True,
    linewidths=0.5,
    cbar_kws={"shrink": 0.8}
)

plt.title("Matrice de Corrélation des Paires FX", fontsize=14)
plt.xticks(rotation=45)
plt.yticks(rotation=0)
plt.tight_layout()
plt.show()

TRADING_DAYS = 252
WINDOW = 60  # fenêtre de 60 jours

def mu_sigma_at_date(returns_df, end_date):
    r = returns_df.loc[returns_df.index < end_date].dropna(how="any")
    r_win = r.iloc[-WINDOW:]

    mu = r_win.mean() * TRADING_DAYS
    Sigma = r_win.cov() * TRADING_DAYS

    return mu, Sigma

test_date = returns_df.index[100]
mu_t, Sigma_t = mu_sigma_at_date(returns_df, test_date)

print(mu_t.head())
print(Sigma_t.shape)

print("Mean of mu_t:", mu_t.mean())
print("Std of mu_t:", mu_t.std())

# Vérifier que la matrice a les bonnes valeurs et est bien conditionnée
# (ici non donc on rajoute un ridge dans la fonction suivante)

eig_min = np.linalg.eigvalsh(Sigma_t.values).min()
eig_max = np.linalg.eigvalsh(Sigma_t.values).max()
cond = eig_max / max(eig_min, 1e-12)

print("min eigenvalue:", eig_min)
print("max eigenvalue:", eig_max)
print("condition approx:", cond)

# --- 1. Fonctions d'Optimisation (CVXPY) ---

def solve_min_variance(mu, Sigma, cap=0.2, eps=1e-4):
    """Minimise la variance du portefeuille."""
    n = len(mu)
    Sigma_psd = Sigma + eps * np.eye(n) # Régularisation

    w = cp.Variable(n)
    objective = cp.Minimize(cp.quad_form(w, Sigma_psd))

    # Contraintes : somme=1, poids positifs, poids max <= cap
    constraints = [cp.sum(w) == 1, w >= 0]
    if cap is not None: constraints.append(w <= cap)

    prob = cp.Problem(objective, constraints)
    try:
        prob.solve(solver=cp.SCS, verbose=False)
        return np.maximum(w.value, 0) # Nettoyage des petites valeurs négatives
    except:
        return np.ones(n)/n # Fallback équipondéré si échec

def solve_max_return(mu, Sigma, cap=0.2, eps=1e-4):
    """Maximise le rendement espéré (Attention: très risqué)."""
    n = len(mu)
    w = cp.Variable(n)
    objective = cp.Maximize(mu @ w)

    constraints = [cp.sum(w) == 1, w >= 0]
    if cap is not None: constraints.append(w <= cap)

    prob = cp.Problem(objective, constraints)
    try:
        prob.solve(solver=cp.SCS, verbose=False)
        return np.maximum(w.value, 0)
    except:
        return np.ones(n)/n

def solve_max_sharpe(mu, Sigma, cap=0.2, eps=1e-4):
    """
    Maximise le Ratio de Sharpe.
    Utilise la transformation de Charnes-Cooper pour rendre le problème convexe.
    """
    n = len(mu)
    # Si tous les rendements sont négatifs, on se rabat sur le Min Variance
    if np.max(mu) < 0:
        return solve_min_variance(mu, Sigma, cap, eps)

    Sigma_psd = Sigma + eps * np.eye(n)

    # Changement de variable : y = w / k
    y = cp.Variable(n)
    k = cp.Variable()

    # Maximize mu^T * y
    objective = cp.Maximize(mu @ y)

    constraints = [
        cp.quad_form(y, Sigma_psd) <= 1, # Variance bornée dans l'espace transformé
        cp.sum(y) == k,
        y >= 0,
        k >= 0
    ]

    if cap is not None:
        constraints.append(y <= cap * k) # w <= cap devient y <= cap * k

    prob = cp.Problem(objective, constraints)
    try:
        prob.solve(solver=cp.SCS, verbose=False)
        if k.value is None or k.value < 1e-6: return np.ones(n)/n

        # Retour aux poids originaux w = y / k
        w_res = y.value / k.value
        return np.maximum(w_res, 0)
    except:
        return np.ones(n)/n

# --- 2. Moteur de Backtest ---

def run_backtest(returns_df, strategy_fn, window=60, cap=0.2):
    # Fréquence de rebalancement : Début de mois (MS)
    rebal_dates = returns_df.resample("MS").first().index
    portfolio_daily_returns = []

    # Date de début effective (après la première fenêtre)
    start_idx = 0
    for i, date in enumerate(rebal_dates):
        if len(returns_df.loc[:date]) >= window:
            start_idx = i
            break

    current_weights = np.ones(returns_df.shape[1]) / returns_df.shape[1]
    TRADING_DAYS = 252

    for i in range(start_idx, len(rebal_dates)):
        curr_date = rebal_dates[i]
        # Prochaine date de rebalancement (ou fin des données)
        next_date = rebal_dates[i+1] if i < len(rebal_dates)-1 else returns_df.index[-1]

        # 1. Données historiques pour l'optimisation
        hist_data = returns_df.loc[:curr_date].iloc[-window:]

        # Calcul Mu et Sigma annualisés
        mu = hist_data.mean().values * TRADING_DAYS
        Sigma = hist_data.cov().values * TRADING_DAYS

        # 2. Optimisation des poids
        try:
            w = strategy_fn(mu, Sigma, cap=cap)
            # Normalisation pour être sûr que somme(w) = 1
            if np.sum(w) > 0: w = w / np.sum(w)
        except Exception as e:
            print(f"Erreur opti {curr_date}: {e}")
            w = current_weights

        current_weights = w

        # 3. Application sur la période suivante (curr_date à next_date]
        mask = (returns_df.index > curr_date) & (returns_df.index <= next_date)
        period_returns = returns_df.loc[mask]

        if period_returns.empty: continue

        # Rendement du portefeuille = produit scalaire
        p_rets = period_returns.dot(w)
        portfolio_daily_returns.append(p_rets)

    return pd.concat(portfolio_daily_returns)

# --- 3. Exécution et Comparaison ---

# Lancer les 3 backtests
ret_mv = run_backtest(returns_df, solve_min_variance, window=60)
ret_mr = run_backtest(returns_df, solve_max_return, window=60)
ret_ms = run_backtest(returns_df, solve_max_sharpe, window=60)

# Créer un DataFrame pour les courbes
equity_df = pd.DataFrame({
    "Min Variance": (1 + ret_mv).cumprod(),
    "Max Return (Risky)": (1 + ret_mr).cumprod(),
    "Max Sharpe (Balanced)": (1 + ret_ms).cumprod()
})

strategies = {
    "Min Variance": ret_mv,
    "Max Return": ret_mr,
    "Max Sharpe": ret_ms
}

# Tracer
plt.figure(figsize=(12, 6))
plt.plot(equity_df)
plt.title("Comparaison des Stratégies (Equity Curve)")
plt.legend(equity_df.columns)
plt.grid(True)
plt.show()

def plot_combined_drawdowns(returns_data):
    plt.figure(figsize=(12, 6))

    for name, r in returns_data.items():
        if r is None or len(r) == 0: continue

        equity = (1 + r).cumprod()
        peak = equity.cummax()
        drawdown = (equity - peak) / peak

        plt.plot(drawdown.index, drawdown, label=name, linewidth=1.5, alpha=0.8)


    plt.title("Comparaison des Drawdowns (Profondeur des pertes)")
    plt.ylabel("Drawdown (%)")
    plt.axhline(0, color='black', lw=1) # Ligne zéro
    plt.legend()
    plt.grid(True, which="major", linestyle="--", alpha=0.6)
    plt.show()

plot_combined_drawdowns(strategies)

"""#Métriques"""

def get_metrics_table(returns_data, risk_free_rate=0.0):
    """
    Génère un tableau de métriques de performance pour vos portefeuilles.

    Args:
        returns_data (dict): Dictionnaire contenant vos séries de rendements.
                             Ex: {"Min Var": ret_mv, "Max Sharpe": ret_ms}
        risk_free_rate (float): Taux sans risque annuel (par défaut 0.0)

    Returns:
        pd.DataFrame: Tableau comparatif des performances
    """
    metrics = []
    TRADING_DAYS = 252

    # On itère sur chaque stratégie du dictionnaire
    for name, r in returns_data.items():
        if r is None or len(r) == 0:
            continue

        # Calcul de la courbe d'equity
        equity = (1 + r).cumprod()

        # Rendement Total (Fin / Début - 1)
        total_ret = equity.iloc[-1] - 1

        # Volatilité Annualisée (Std Dev * sqrt(252))
        ann_vol = r.std() * np.sqrt(TRADING_DAYS)

        # Ratio de Sharpe (Rendement Annuel / Volatilité Annuelle)
        ann_ret = r.mean() * TRADING_DAYS
        sharpe = (ann_ret - risk_free_rate) / ann_vol if ann_vol != 0 else 0

        # Max Drawdown (Perte maximale depuis un sommet
        peak = equity.cummax()
        drawdown = (equity - peak) / peak
        max_dd = drawdown.min()

        # Ajout au tableau
        metrics.append({
            "Stratégie": name,
            "Rendement Total": total_ret,
            "Volatilité (An)": ann_vol,
            "Ratio de Sharpe": sharpe,
            "Max Drawdown": max_dd
        })

    # Création du DataFrame final
    df = pd.DataFrame(metrics)
    if not df.empty:
        df = df.set_index("Stratégie")

    return df

df_results = get_metrics_table(strategies)
styled_table = df_results.style.format({
    'Rendement Total': '{:+.1%}',
    'Volatilité (An)': '{:.1%}',
    'Ratio de Sharpe': '{:.2f}',
    'Max Drawdown': '{:.1%}'
}).background_gradient(subset=['Ratio de Sharpe'], cmap='RdYlGn')

display(styled_table)